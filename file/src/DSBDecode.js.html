<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/DSBDecode.js | dsbapi</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="An api for mobile.dsbcontrol.de"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="dsbapi"><meta property="twitter:description" content="An api for mobile.dsbcontrol.de"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/TheNoim/DSBAPI.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/index.js~DSB.html">DSB</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/DSBDecode.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import pako from &apos;pako&apos;;

function atob(a) {
	for (
		var b,
			c,
			d =
				&apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&apos;,
			e = String(a).replace(/=+$/, &apos;&apos;),
			f = 0,
			g = 0,
			h = &apos;&apos;;
		(c = e.charAt(g++));
		~c &amp;&amp; ((b = f % 4 ? 64 * b + c : c), f++ % 4)
			? (h += String.fromCharCode(255 &amp; (b &gt;&gt; ((-2 * f) &amp; 6))))
			: 0
	)
		c = d.indexOf(c);
	return h;
}

/**
 *
 * @private
 * @param {*} ToDecode
 */
export default function(ToDecode) {
	var b = StringView.base64ToBytes(ToDecode),
		c = pako.inflate(b),
		d = new StringView(c),
		e = d.toString(),
		f = JSON.parse(e);
	return f;
}

function StringView(
	vInput,
	sEncoding /* optional (default: UTF-8) */,
	nOffset /* optional */,
	nLength /* optional */
) {
	var fTAView,
		aWhole,
		aRaw,
		fPutOutptCode,
		fGetOutptChrSize,
		nInptLen,
		nStartIdx = isFinite(nOffset) ? nOffset : 0,
		nTranscrType = 15;

	if (sEncoding) {
		this.encoding = sEncoding.toString();
	}

	encSwitch: switch (this.encoding) {
		case &apos;UTF-8&apos;:
			fPutOutptCode = StringView.putUTF8CharCode;
			fGetOutptChrSize = StringView.getUTF8CharLength;
			fTAView = Uint8Array;
			break encSwitch;
		case &apos;UTF-16&apos;:
			fPutOutptCode = StringView.putUTF16CharCode;
			fGetOutptChrSize = StringView.getUTF16CharLength;
			fTAView = Uint16Array;
			break encSwitch;
		case &apos;UTF-32&apos;:
			fTAView = Uint32Array;
			nTranscrType &amp;= 14;
			break encSwitch;
		default:
			/* case &quot;ASCII&quot;, or case &quot;BinaryString&quot; or unknown cases */
			fTAView = Uint8Array;
			nTranscrType &amp;= 14;
	}

	typeSwitch: switch (typeof vInput) {
		case &apos;string&apos;:
			/* the input argument is a primitive string: a new buffer will be created. */
			nTranscrType &amp;= 7;
			break typeSwitch;
		case &apos;object&apos;:
			classSwitch: switch (vInput.constructor) {
				case StringView:
					/* the input argument is a stringView: a new buffer will be created. */
					nTranscrType &amp;= 3;
					break typeSwitch;
				case String:
					/* the input argument is an objectified string: a new buffer will be created. */
					nTranscrType &amp;= 7;
					break typeSwitch;
				case ArrayBuffer:
					/* the input argument is an arrayBuffer: the buffer will be shared. */
					aWhole = new fTAView(vInput);
					nInptLen =
						this.encoding === &apos;UTF-32&apos;
							? vInput.byteLength &gt;&gt;&gt; 2
							: this.encoding === &apos;UTF-16&apos;
							? vInput.byteLength &gt;&gt;&gt; 1
							: vInput.byteLength;
					aRaw =
						nStartIdx === 0 &amp;&amp;
						(!isFinite(nLength) || nLength === nInptLen)
							? aWhole
							: new fTAView(
									vInput,
									nStartIdx,
									!isFinite(nLength)
										? nInptLen - nStartIdx
										: nLength
							  );

					break typeSwitch;
				case Uint32Array:
				case Uint16Array:
				case Uint8Array:
					/* the input argument is a typedArray: the buffer, and possibly the array itself, will be shared. */
					fTAView = vInput.constructor;
					nInptLen = vInput.length;
					aWhole =
						vInput.byteOffset === 0 &amp;&amp;
						vInput.length ===
							(fTAView === Uint32Array
								? vInput.buffer.byteLength &gt;&gt;&gt; 2
								: fTAView === Uint16Array
								? vInput.buffer.byteLength &gt;&gt;&gt; 1
								: vInput.buffer.byteLength)
							? vInput
							: new fTAView(vInput.buffer);
					aRaw =
						nStartIdx === 0 &amp;&amp;
						(!isFinite(nLength) || nLength === nInptLen)
							? vInput
							: vInput.subarray(
									nStartIdx,
									isFinite(nLength)
										? nStartIdx + nLength
										: nInptLen
							  );

					break typeSwitch;
				default:
					/* the input argument is an array or another serializable object: a new typedArray will be created. */
					aWhole = new fTAView(vInput);
					nInptLen = aWhole.length;
					aRaw =
						nStartIdx === 0 &amp;&amp;
						(!isFinite(nLength) || nLength === nInptLen)
							? aWhole
							: aWhole.subarray(
									nStartIdx,
									isFinite(nLength)
										? nStartIdx + nLength
										: nInptLen
							  );
			}
			break typeSwitch;
		default:
			/* the input argument is a number, a boolean or a function: a new typedArray will be created. */
			aWhole = aRaw = new fTAView(Number(vInput) || 0);
	}

	if (nTranscrType &lt; 8) {
		var vSource,
			nOutptLen,
			nCharStart,
			nCharEnd,
			nEndIdx,
			fGetInptChrSize,
			fGetInptChrCode;

		if (nTranscrType &amp; 4) {
			/* input is string */

			vSource = vInput;
			nOutptLen = nInptLen = vSource.length;
			nTranscrType ^= this.encoding === &apos;UTF-32&apos; ? 0 : 2;
			/* ...or...: nTranscrType ^= Number(this.encoding !== &quot;UTF-32&quot;) &lt;&lt; 1; */
			nStartIdx = nCharStart = nOffset
				? Math.max((nOutptLen + nOffset) % nOutptLen, 0)
				: 0;
			nEndIdx = nCharEnd =
				(Number.isInteger(nLength)
					? Math.min(Math.max(nLength, 0) + nStartIdx, nOutptLen)
					: nOutptLen) - 1;
		} else {
			/* input is stringView */

			vSource = vInput.rawData;
			nInptLen = vInput.makeIndex();
			nStartIdx = nCharStart = nOffset
				? Math.max((nInptLen + nOffset) % nInptLen, 0)
				: 0;
			nOutptLen = Number.isInteger(nLength)
				? Math.min(Math.max(nLength, 0), nInptLen - nCharStart)
				: nInptLen;
			nEndIdx = nCharEnd = nOutptLen + nCharStart;

			if (vInput.encoding === &apos;UTF-8&apos;) {
				fGetInptChrSize = StringView.getUTF8CharLength;
				fGetInptChrCode = StringView.loadUTF8CharCode;
			} else if (vInput.encoding === &apos;UTF-16&apos;) {
				fGetInptChrSize = StringView.getUTF16CharLength;
				fGetInptChrCode = StringView.loadUTF16CharCode;
			} else {
				nTranscrType &amp;= 1;
			}
		}

		if (
			nOutptLen === 0 ||
			(nTranscrType &lt; 4 &amp;&amp;
				vSource.encoding === this.encoding &amp;&amp;
				nCharStart === 0 &amp;&amp;
				nOutptLen === nInptLen)
		) {
			/* the encoding is the same, the length too and the offset is 0... or the input is empty! */

			nTranscrType = 7;
		}

		conversionSwitch: switch (nTranscrType) {
			case 0:
				/* both the source and the new StringView have a fixed-length encoding... */

				aWhole = new fTAView(nOutptLen);
				for (
					var nOutptIdx = 0;
					nOutptIdx &lt; nOutptLen;
					aWhole[nOutptIdx] = vSource[nStartIdx + nOutptIdx++]
				);
				break conversionSwitch;

			case 1:
				/* the source has a fixed-length encoding but the new StringView has a variable-length encoding... */

				/* mapping... */

				nOutptLen = 0;

				for (var nInptIdx = nStartIdx; nInptIdx &lt; nEndIdx; nInptIdx++) {
					nOutptLen += fGetOutptChrSize(vSource[nInptIdx]);
				}

				aWhole = new fTAView(nOutptLen);

				/* transcription of the source... */

				for (
					var nInptIdx = nStartIdx, nOutptIdx = 0;
					nOutptIdx &lt; nOutptLen;
					nInptIdx++
				) {
					nOutptIdx = fPutOutptCode(
						aWhole,
						vSource[nInptIdx],
						nOutptIdx
					);
				}

				break conversionSwitch;

			case 2:
				/* the source has a variable-length encoding but the new StringView has a fixed-length encoding... */

				/* mapping... */

				nStartIdx = 0;

				var nChrCode;

				for (nChrIdx = 0; nChrIdx &lt; nCharStart; nChrIdx++) {
					nChrCode = fGetInptChrCode(vSource, nStartIdx);
					nStartIdx += fGetInptChrSize(nChrCode);
				}

				aWhole = new fTAView(nOutptLen);

				/* transcription of the source... */

				for (
					var nInptIdx = nStartIdx, nOutptIdx = 0;
					nOutptIdx &lt; nOutptLen;
					nInptIdx += fGetInptChrSize(nChrCode), nOutptIdx++
				) {
					nChrCode = fGetInptChrCode(vSource, nInptIdx);
					aWhole[nOutptIdx] = nChrCode;
				}

				break conversionSwitch;

			case 3:
				/* both the source and the new StringView have a variable-length encoding... */

				/* mapping... */

				nOutptLen = 0;

				var nChrCode;

				for (
					var nChrIdx = 0, nInptIdx = 0;
					nChrIdx &lt; nCharEnd;
					nInptIdx += fGetInptChrSize(nChrCode)
				) {
					nChrCode = fGetInptChrCode(vSource, nInptIdx);
					if (nChrIdx === nCharStart) {
						nStartIdx = nInptIdx;
					}
					if (++nChrIdx &gt; nCharStart) {
						nOutptLen += fGetOutptChrSize(nChrCode);
					}
				}

				aWhole = new fTAView(nOutptLen);

				/* transcription... */

				for (
					var nInptIdx = nStartIdx, nOutptIdx = 0;
					nOutptIdx &lt; nOutptLen;
					nInptIdx += fGetInptChrSize(nChrCode)
				) {
					nChrCode = fGetInptChrCode(vSource, nInptIdx);
					nOutptIdx = fPutOutptCode(aWhole, nChrCode, nOutptIdx);
				}

				break conversionSwitch;

			case 4:
				/* DOMString to ASCII or BinaryString or other unknown encodings */

				aWhole = new fTAView(nOutptLen);

				/* transcription... */

				for (var nIdx = 0; nIdx &lt; nOutptLen; nIdx++) {
					aWhole[nIdx] = vSource.charCodeAt(nIdx) &amp; 0xff;
				}

				break conversionSwitch;

			case 5:
				/* DOMString to UTF-8 or to UTF-16 */

				/* mapping... */

				nOutptLen = 0;

				for (var nMapIdx = 0; nMapIdx &lt; nInptLen; nMapIdx++) {
					if (nMapIdx === nCharStart) {
						nStartIdx = nOutptLen;
					}
					nOutptLen += fGetOutptChrSize(vSource.charCodeAt(nMapIdx));
					if (nMapIdx === nCharEnd) {
						nEndIdx = nOutptLen;
					}
				}

				aWhole = new fTAView(nOutptLen);

				/* transcription... */

				for (
					var nOutptIdx = 0, nChrIdx = 0;
					nOutptIdx &lt; nOutptLen;
					nChrIdx++
				) {
					nOutptIdx = fPutOutptCode(
						aWhole,
						vSource.charCodeAt(nChrIdx),
						nOutptIdx
					);
				}

				break conversionSwitch;

			case 6:
				/* DOMString to UTF-32 */

				aWhole = new fTAView(nOutptLen);

				/* transcription... */

				for (var nIdx = 0; nIdx &lt; nOutptLen; nIdx++) {
					aWhole[nIdx] = vSource.charCodeAt(nIdx);
				}

				break conversionSwitch;

			case 7:
				aWhole = new fTAView(nOutptLen ? vSource : 0);
				break conversionSwitch;
		}

		aRaw =
			nTranscrType &gt; 3 &amp;&amp; (nStartIdx &gt; 0 || nEndIdx &lt; aWhole.length - 1)
				? aWhole.subarray(nStartIdx, nEndIdx)
				: aWhole;
	}

	this.buffer = aWhole.buffer;
	this.bufferView = aWhole;
	this.rawData = aRaw;

	Object.freeze(this);
}

/* CONSTRUCTOR&apos;S METHODS */

StringView.loadUTF8CharCode = function(aChars, nIdx) {
	var nLen = aChars.length,
		nPart = aChars[nIdx];

	return nPart &gt; 251 &amp;&amp; nPart &lt; 254 &amp;&amp; nIdx + 5 &lt; nLen
		? /* (nPart - 252 &lt;&lt; 30) may be not safe in ECMAScript! So...: */
		  /* six bytes */ (nPart - 252) * 1073741824 +
				((aChars[nIdx + 1] - 128) &lt;&lt; 24) +
				((aChars[nIdx + 2] - 128) &lt;&lt; 18) +
				((aChars[nIdx + 3] - 128) &lt;&lt; 12) +
				((aChars[nIdx + 4] - 128) &lt;&lt; 6) +
				aChars[nIdx + 5] -
				128
		: nPart &gt; 247 &amp;&amp; nPart &lt; 252 &amp;&amp; nIdx + 4 &lt; nLen
		? /* five bytes */ ((nPart - 248) &lt;&lt; 24) +
		  ((aChars[nIdx + 1] - 128) &lt;&lt; 18) +
		  ((aChars[nIdx + 2] - 128) &lt;&lt; 12) +
		  ((aChars[nIdx + 3] - 128) &lt;&lt; 6) +
		  aChars[nIdx + 4] -
		  128
		: nPart &gt; 239 &amp;&amp; nPart &lt; 248 &amp;&amp; nIdx + 3 &lt; nLen
		? /* four bytes */ ((nPart - 240) &lt;&lt; 18) +
		  ((aChars[nIdx + 1] - 128) &lt;&lt; 12) +
		  ((aChars[nIdx + 2] - 128) &lt;&lt; 6) +
		  aChars[nIdx + 3] -
		  128
		: nPart &gt; 223 &amp;&amp; nPart &lt; 240 &amp;&amp; nIdx + 2 &lt; nLen
		? /* three bytes */ ((nPart - 224) &lt;&lt; 12) +
		  ((aChars[nIdx + 1] - 128) &lt;&lt; 6) +
		  aChars[nIdx + 2] -
		  128
		: nPart &gt; 191 &amp;&amp; nPart &lt; 224 &amp;&amp; nIdx + 1 &lt; nLen
		? /* two bytes */ ((nPart - 192) &lt;&lt; 6) + aChars[nIdx + 1] - 128
		: /* one byte */ nPart;
};

StringView.putUTF8CharCode = function(aTarget, nChar, nPutAt) {
	var nIdx = nPutAt;

	if (nChar &lt; 0x80 /* 128 */) {
		/* one byte */
		aTarget[nIdx++] = nChar;
	} else if (nChar &lt; 0x800 /* 2048 */) {
		/* two bytes */
		aTarget[nIdx++] = 0xc0 /* 192 */ + (nChar &gt;&gt;&gt; 6);
		aTarget[nIdx++] = 0x80 /* 128 */ + (nChar &amp; 0x3f) /* 63 */;
	} else if (nChar &lt; 0x10000 /* 65536 */) {
		/* three bytes */
		aTarget[nIdx++] = 0xe0 /* 224 */ + (nChar &gt;&gt;&gt; 12);
		aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar &gt;&gt;&gt; 6) &amp; 0x3f) /* 63 */;
		aTarget[nIdx++] = 0x80 /* 128 */ + (nChar &amp; 0x3f) /* 63 */;
	} else if (nChar &lt; 0x200000 /* 2097152 */) {
		/* four bytes */
		aTarget[nIdx++] = 0xf0 /* 240 */ + (nChar &gt;&gt;&gt; 18);
		aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar &gt;&gt;&gt; 12) &amp; 0x3f) /* 63 */;
		aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar &gt;&gt;&gt; 6) &amp; 0x3f) /* 63 */;
		aTarget[nIdx++] = 0x80 /* 128 */ + (nChar &amp; 0x3f) /* 63 */;
	} else if (nChar &lt; 0x4000000 /* 67108864 */) {
		/* five bytes */
		aTarget[nIdx++] = 0xf8 /* 248 */ + (nChar &gt;&gt;&gt; 24);
		aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar &gt;&gt;&gt; 18) &amp; 0x3f) /* 63 */;
		aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar &gt;&gt;&gt; 12) &amp; 0x3f) /* 63 */;
		aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar &gt;&gt;&gt; 6) &amp; 0x3f) /* 63 */;
		aTarget[nIdx++] = 0x80 /* 128 */ + (nChar &amp; 0x3f) /* 63 */;
	} /* if (nChar &lt;= 0x7fffffff) */ else {
		/* 2147483647 */
		/* six bytes */
		aTarget[nIdx++] =
			0xfc /* 252 */ +
			/* (nChar &gt;&gt;&gt; 30) may be not safe in ECMAScript! So...: */ nChar /
				1073741824;
		aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar &gt;&gt;&gt; 24) &amp; 0x3f) /* 63 */;
		aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar &gt;&gt;&gt; 18) &amp; 0x3f) /* 63 */;
		aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar &gt;&gt;&gt; 12) &amp; 0x3f) /* 63 */;
		aTarget[nIdx++] = 0x80 /* 128 */ + ((nChar &gt;&gt;&gt; 6) &amp; 0x3f) /* 63 */;
		aTarget[nIdx++] = 0x80 /* 128 */ + (nChar &amp; 0x3f) /* 63 */;
	}

	return nIdx;
};

StringView.getUTF8CharLength = function(nChar) {
	return nChar &lt; 0x80
		? 1
		: nChar &lt; 0x800
		? 2
		: nChar &lt; 0x10000
		? 3
		: nChar &lt; 0x200000
		? 4
		: nChar &lt; 0x4000000
		? 5
		: 6;
};

StringView.loadUTF16CharCode = function(aChars, nIdx) {
	/* UTF-16 to DOMString decoding algorithm */
	var nFrstChr = aChars[nIdx];

	return nFrstChr &gt; 0xd7bf /* 55231 */ &amp;&amp; nIdx + 1 &lt; aChars.length
		? ((nFrstChr - 0xd800) /* 55296 */ &lt;&lt; 10) +
				aChars[nIdx + 1] +
				0x2400 /* 9216 */
		: nFrstChr;
};

StringView.putUTF16CharCode = function(aTarget, nChar, nPutAt) {
	var nIdx = nPutAt;

	if (nChar &lt; 0x10000 /* 65536 */) {
		/* one element */
		aTarget[nIdx++] = nChar;
	} else {
		/* two elements */
		aTarget[nIdx++] = 0xd7c0 /* 55232 */ + (nChar &gt;&gt;&gt; 10);
		aTarget[nIdx++] = 0xdc00 /* 56320 */ + (nChar &amp; 0x3ff) /* 1023 */;
	}

	return nIdx;
};

StringView.getUTF16CharLength = function(nChar) {
	return nChar &lt; 0x10000 ? 1 : 2;
};

/* Array of bytes to base64 string decoding */

StringView.b64ToUint6 = function(nChr) {
	return nChr &gt; 64 &amp;&amp; nChr &lt; 91
		? nChr - 65
		: nChr &gt; 96 &amp;&amp; nChr &lt; 123
		? nChr - 71
		: nChr &gt; 47 &amp;&amp; nChr &lt; 58
		? nChr + 4
		: nChr === 43
		? 62
		: nChr === 47
		? 63
		: 0;
};

StringView.uint6ToB64 = function(nUint6) {
	return nUint6 &lt; 26
		? nUint6 + 65
		: nUint6 &lt; 52
		? nUint6 + 71
		: nUint6 &lt; 62
		? nUint6 - 4
		: nUint6 === 62
		? 43
		: nUint6 === 63
		? 47
		: 65;
};

/* Base64 string to array encoding */

StringView.bytesToBase64 = function(aBytes) {
	var eqLen = (3 - (aBytes.length % 3)) % 3,
		sB64Enc = &apos;&apos;;

	for (
		var nMod3, nLen = aBytes.length, nUint24 = 0, nIdx = 0;
		nIdx &lt; nLen;
		nIdx++
	) {
		nMod3 = nIdx % 3;
		/* Uncomment the following line in order to split the output in lines 76-character long: */
		/*
         if (nIdx &gt; 0 &amp;&amp; (nIdx * 4 / 3) % 76 === 0) { sB64Enc += &quot;\r\n&quot;; }
         */
		nUint24 |= aBytes[nIdx] &lt;&lt; ((16 &gt;&gt;&gt; nMod3) &amp; 24);
		if (nMod3 === 2 || aBytes.length - nIdx === 1) {
			sB64Enc += String.fromCharCode(
				StringView.uint6ToB64((nUint24 &gt;&gt;&gt; 18) &amp; 63),
				StringView.uint6ToB64((nUint24 &gt;&gt;&gt; 12) &amp; 63),
				StringView.uint6ToB64((nUint24 &gt;&gt;&gt; 6) &amp; 63),
				StringView.uint6ToB64(nUint24 &amp; 63)
			);
			nUint24 = 0;
		}
	}

	return eqLen === 0
		? sB64Enc
		: sB64Enc.substring(0, sB64Enc.length - eqLen) +
				(eqLen === 1 ? &apos;=&apos; : &apos;==&apos;);
};

StringView.base64ToBytes = function(sBase64, nBlockBytes) {
	var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, &apos;&apos;),
		nInLen = sB64Enc.length,
		nOutLen = nBlockBytes
			? Math.ceil(((nInLen * 3 + 1) &gt;&gt;&gt; 2) / nBlockBytes) * nBlockBytes
			: (nInLen * 3 + 1) &gt;&gt;&gt; 2,
		aBytes = new Uint8Array(nOutLen);

	for (
		var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0;
		nInIdx &lt; nInLen;
		nInIdx++
	) {
		nMod4 = nInIdx &amp; 3;
		nUint24 |=
			StringView.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) &lt;&lt;
			(18 - 6 * nMod4);
		if (nMod4 === 3 || nInLen - nInIdx === 1) {
			for (
				nMod3 = 0;
				nMod3 &lt; 3 &amp;&amp; nOutIdx &lt; nOutLen;
				nMod3++, nOutIdx++
			) {
				aBytes[nOutIdx] = (nUint24 &gt;&gt;&gt; ((16 &gt;&gt;&gt; nMod3) &amp; 24)) &amp; 255;
			}
			nUint24 = 0;
		}
	}

	return aBytes;
};

StringView.makeFromBase64 = function(
	sB64Inpt,
	sEncoding,
	nByteOffset,
	nLength
) {
	return new StringView(
		sEncoding === &apos;UTF-16&apos; || sEncoding === &apos;UTF-32&apos;
			? StringView.base64ToBytes(sB64Inpt, sEncoding === &apos;UTF-16&apos; ? 2 : 4)
					.buffer
			: StringView.base64ToBytes(sB64Inpt),
		sEncoding,
		nByteOffset,
		nLength
	);
};

/* DEFAULT VALUES */

StringView.prototype.encoding = &apos;UTF-8&apos;; /* Default encoding... */

/* INSTANCES&apos; METHODS */

StringView.prototype.makeIndex = function(nChrLength, nStartFrom) {
	var aTarget = this.rawData,
		nChrEnd,
		nRawLength = aTarget.length,
		nStartIdx = nStartFrom || 0,
		nIdxEnd = nStartIdx,
		nStopAtChr = isNaN(nChrLength) ? Infinity : nChrLength;

	if (nChrLength + 1 &gt; aTarget.length) {
		throw new RangeError(
			&quot;StringView.prototype.makeIndex - The offset can&apos;t be major than the length of the array - 1.&quot;
		);
	}

	switch (this.encoding) {
		case &apos;UTF-8&apos;:
			var nPart;

			for (
				nChrEnd = 0;
				nIdxEnd &lt; nRawLength &amp;&amp; nChrEnd &lt; nStopAtChr;
				nChrEnd++
			) {
				nPart = aTarget[nIdxEnd];
				nIdxEnd +=
					nPart &gt; 251 &amp;&amp; nPart &lt; 254 &amp;&amp; nIdxEnd + 5 &lt; nRawLength
						? 6
						: nPart &gt; 247 &amp;&amp; nPart &lt; 252 &amp;&amp; nIdxEnd + 4 &lt; nRawLength
						? 5
						: nPart &gt; 239 &amp;&amp; nPart &lt; 248 &amp;&amp; nIdxEnd + 3 &lt; nRawLength
						? 4
						: nPart &gt; 223 &amp;&amp; nPart &lt; 240 &amp;&amp; nIdxEnd + 2 &lt; nRawLength
						? 3
						: nPart &gt; 191 &amp;&amp; nPart &lt; 224 &amp;&amp; nIdxEnd + 1 &lt; nRawLength
						? 2
						: 1;
			}

			break;

		case &apos;UTF-16&apos;:
			for (
				nChrEnd = nStartIdx;
				nIdxEnd &lt; nRawLength &amp;&amp; nChrEnd &lt; nStopAtChr;
				nChrEnd++
			) {
				nIdxEnd +=
					aTarget[nIdxEnd] &gt; 0xd7bf /* 55231 */ &amp;&amp;
					nIdxEnd + 1 &lt; aTarget.length
						? 2
						: 1;
			}

			break;

		default:
			nIdxEnd = nChrEnd = isFinite(nChrLength)
				? nChrLength
				: nRawLength - 1;
	}

	if (nChrLength) {
		return nIdxEnd;
	}

	return nChrEnd;
};

StringView.prototype.toBase64 = function(bWholeBuffer) {
	return StringView.bytesToBase64(
		bWholeBuffer
			? this.bufferView.constructor === Uint8Array
				? this.bufferView
				: new Uint8Array(this.buffer)
			: this.rawData.constructor === Uint8Array
			? this.rawData
			: new Uint8Array(
					this.buffer,
					this.rawData.byteOffset,
					this.rawData.length &lt;&lt;
						(this.rawData.constructor === Uint16Array ? 1 : 2)
			  )
	);
};

StringView.prototype.subview = function(
	nCharOffset /* optional */,
	nCharLength /* optional */
) {
	var nRawSubLen,
		nRawSubOffset,
		nSubOffset,
		nSubLen,
		bVariableLen = this.encoding === &apos;UTF-8&apos; || this.encoding === &apos;UTF-16&apos;,
		nThisLen,
		nRawLen = this.rawData.length;

	if (nRawLen === 0) {
		return new StringView(this.buffer, this.encoding);
	}

	nThisLen = bVariableLen ? this.makeIndex() : nRawLen;
	nSubOffset = nCharOffset
		? nCharOffset + 1 &gt; nThisLen
			? nThisLen
			: Math.max((nThisLen + nCharOffset) % nThisLen, 0)
		: 0;
	nSubLen = Number.isInteger(nCharLength)
		? Math.max(nCharLength, 0) + nSubOffset &gt; nThisLen
			? nThisLen - nSubOffset
			: nCharLength
		: nThisLen - nSubOffset;

	if (nSubOffset === 0 &amp;&amp; nSubLen === nThisLen) {
		return this;
	}

	if (bVariableLen) {
		nRawSubOffset =
			nSubOffset &lt; nThisLen ? this.makeIndex(nSubOffset) : nThisLen;
		nRawSubLen = nSubLen
			? this.makeIndex(nSubLen, nRawSubOffset) - nRawSubOffset
			: 0;
	} else {
		nRawSubOffset = nSubOffset;
		nRawSubLen = nSubLen;
	}

	if (this.encoding === &apos;UTF-16&apos;) {
		nRawSubOffset &lt;&lt;= 1;
	} else if (this.encoding === &apos;UTF-32&apos;) {
		nRawSubOffset &lt;&lt;= 2;
	}

	return new StringView(
		this.buffer,
		this.encoding,
		this.rawData.byteOffset + nRawSubOffset,
		nRawSubLen
	);
};

StringView.prototype.forEachChar = function(
	fCallback,
	oThat,
	nChrOffset,
	nChrLen
) {
	var aSource = this.rawData,
		nRawEnd,
		nRawIdx;

	if (this.encoding === &apos;UTF-8&apos; || this.encoding === &apos;UTF-16&apos;) {
		var fGetInptChrSize, fGetInptChrCode;

		if (this.encoding === &apos;UTF-8&apos;) {
			fGetInptChrSize = StringView.getUTF8CharLength;
			fGetInptChrCode = StringView.loadUTF8CharCode;
		} else if (this.encoding === &apos;UTF-16&apos;) {
			fGetInptChrSize = StringView.getUTF16CharLength;
			fGetInptChrCode = StringView.loadUTF16CharCode;
		}

		nRawIdx = isFinite(nChrOffset) ? this.makeIndex(nChrOffset) : 0;
		nRawEnd = isFinite(nChrLen)
			? this.makeIndex(nChrLen, nRawIdx)
			: aSource.length;

		for (var nChrCode, nChrIdx = 0; nRawIdx &lt; nRawEnd; nChrIdx++) {
			nChrCode = fGetInptChrCode(aSource, nRawIdx);
			fCallback.call(oThat || null, nChrCode, nChrIdx, nRawIdx, aSource);
			nRawIdx += fGetInptChrSize(nChrCode);
		}
	} else {
		nRawIdx = isFinite(nChrOffset) ? nChrOffset : 0;
		nRawEnd = isFinite(nChrLen) ? nChrLen + nRawIdx : aSource.length;

		for (nRawIdx; nRawIdx &lt; nRawEnd; nRawIdx++) {
			fCallback.call(
				oThat || null,
				aSource[nRawIdx],
				nRawIdx,
				nRawIdx,
				aSource
			);
		}
	}
};

StringView.prototype.valueOf = StringView.prototype.toString = function() {
	if (this.encoding !== &apos;UTF-8&apos; &amp;&amp; this.encoding !== &apos;UTF-16&apos;) {
		/* ASCII, UTF-32 or BinaryString to DOMString */
		return String.fromCharCode.apply(null, this.rawData);
	}

	var fGetCode,
		fGetIncr,
		sView = &apos;&apos;;

	if (this.encoding === &apos;UTF-8&apos;) {
		fGetIncr = StringView.getUTF8CharLength;
		fGetCode = StringView.loadUTF8CharCode;
	} else if (this.encoding === &apos;UTF-16&apos;) {
		fGetIncr = StringView.getUTF16CharLength;
		fGetCode = StringView.loadUTF16CharCode;
	}

	for (
		var nChr, nLen = this.rawData.length, nIdx = 0;
		nIdx &lt; nLen;
		nIdx += fGetIncr(nChr)
	) {
		nChr = fGetCode(this.rawData, nIdx);
		sView += String.fromCharCode(nChr);
	}

	return sView;
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
